一，观察下面结构体声明

```
struct
{
int n;
float m;
} aa;
stuct aa td1;
```

上面声明是错误的，aa已经是结构体变量，不能用结构体变量来声明结构体变量。

二，关于拷贝构造函数，观察以下代码：

```
class Point
 {
 public:
 Point(int xx=0, int yy=0)
 {
 X=xx;
 Y=yy;
 }
 Point(Point &p)
 {
 X=p.X;
 Y=p.Y;
 cout<<"*";
 }
 private:
 int X,Y;
 };
 class Line
 {
 public:
 Line (Point xp1, Point xp2):p1(xp1),p2(xp2)
 {}
 private:
 Point p1,p2;
 };
 int main()
 {
 Point myp1(1,1),myp2(4,5);
 Line line(myp1,myp2);              //会打印 **** （4个）
 return 0;
 }
```

这里主要考察了在传值操作时会调用拷贝构造函数，具体如下：

myp1和myp2通过值传递拷贝给xp1和xp2发生两次拷贝构造过程.

p1(xp1),p2(xp2)会发生两次拷贝构造。

如果改为引用传递，即Line (Point& xp1, Point& xp2):p1(xp1),p2(xp2)，则没有发生值传递，前两次拷贝构造不会发生。

三，关于C++内存分配

```
char*p1 = “123456”;
char*p2 = (char*)malloc(10);
```

语句一中，“123456”本身存放在**常量区**，**指针p1中存放的是** “123456”在常量区中的**地址**，**指针p1本身存放在栈区**；

语句二中，malloc从**堆区**分配了10个字节的内存区域，并把这块内存区域的首地址赋给了指针p2，即指针p2中存放是只是一个指向堆区的地址，而**指针p2本身是存放在栈区**。

##### 扩展知识：

一个由C/C++编译的程序占用的内存分为以下几个部分

1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其
操作方式类似于数据结构中的栈。
2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回
收 。
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的
全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另
一块区域。 - 程序结束后由系统释放。
4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放
5、程序代码区—存放函数体的二进制代码

四，const区别

const修饰他最近的对象

```
const int* x;   //同 int const *x;
```

表示指向const对象的int型指针，所指对象不能改变，指针可以改变

```
int* const x;
```

表示指向int型对象的const指针，指针不能该改变，所指的对象可以改变