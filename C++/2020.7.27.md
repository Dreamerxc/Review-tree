##### 一，内联函数与宏定义的区别

​	内联函数和宏的区别在于，**宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。**而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联欢函数要优于宏定义，因为内联函数遵循的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关联上内联扩展，将与一般函数一样进行调用，比较方便。 

​    另外，宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，也就不能享受C++[编译器](http://baike.baidu.com/view/487018.htm)严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性

##### 二，CPU load

CPU load指当前系统中所有ready和running状态的进程数量

##### 三，free一个指针

​		free(pointer); 释放的是指针指向的内存。注意，释放的是内存，不是指针。指针并没有被释放，指针仍然指向原来的存储空间。指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在，只不过现在指针指向的内容是垃圾，是未定义的。因此，释放内存后把指针指向 NULL，防止指针在后面不小心又被解引用了。

##### 四，C++main函数参数

C++的main函数可以没有输入参数，也可以有输入参数，而且只能有两个参数

```
int main(int argc, char* argv[]) 或者 int main(int argc, char** argv)
```

argc表示命令行参数的个数。

argv是一个字符指针型的数组，用来存储命令行参数。

![image-20200727185140750](C:\Users\谯保林\AppData\Roaming\Typora\typora-user-images\image-20200727185140750.png)

![image-20200727185208053](C:\Users\谯保林\AppData\Roaming\Typora\typora-user-images\image-20200727185208053.png)



argv[0]指文件名。

##### 五，堆不能进行静态分配

静态分配是指在编译阶段就能确定大小，由编译器进行分配，堆不可以进行静态分配，堆的申请都是在执行过程中进行的

栈可以通过函数进行动态分配，释放时由编译器自己自动释放

