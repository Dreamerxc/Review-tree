##### 一，浅拷贝引发的错误问题

```
class A{
   int i;
};
class B{
   A *p;
public:
   B(){p=new A;}    //默认构造函数
   ~B(){delete p;}
   B(constB& ths)   //默认拷贝构造函数
   {
   		p = ths.p;
   }
};
void sayHello(B b){
}
int main(){
   B b;
   sayHello(b);
}
```

上述程序引发错误问题，调用sayHello函数时，实参b向形参值传递时调用默认的拷贝构造函数，此时形参对象和原对象的指针指向同一个地方，当函数调用完成后，形参对象发生析构，会将指针p析构掉，但是当程序调用完成后，又会显示的调用析构函数再一次对p指针进行析构，会导致程序奔溃。

##### 当有指针对象或者引用对象时，应该自己重新定义一个拷贝构造函数

```
B(const B& other)
{
	p = new A;
	*p = *(other.p);
}
```

##### 二，观察一下代码

```
int a = 5;
++(a++);
```

上述代码运行错误，a++ = 5,括号里的值为数值5，数值5不能进行++运算。