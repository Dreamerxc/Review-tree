##### 一，函数重载的特征

重载是在编译阶段实现的，编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数

（1）相同的范围（如在同一个类中）

（2）函数名字相同

（3）参数不同（类型不同或者参数个数不同）

##### 二，C++函数重载const

const参数重载只适合与引用传递和指针传递

（1）对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响

（2）在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。

```
class A
{
	public:
		A();
		void foo(int *test);
		void foo(const int *test);
};
A::A(){}
void A::foo(int* test){}
void A::foo(const int* test){}
int main()
{
	const int a = 1;
	b = 2;
	A c;
	c.foo(&a);    
	c.foo(&b);
	return 1;
}
```

c.foo(&a):调用 foo(const int *test)函数

c.foo(&b):调用foo(int *test)函数

扩展：

（1）上述代码无void foo(const int *test)函数，上述程序会发生错误，无法将const int\*转化为const int类型。

（2）上述代码无void foo(int* test)函数，则全部执行void foo(const int *test)函数，可以进行类型转化来进行匹配。

##### 三，内联函数与性能的关系

**内联函数可能会使代码速度\*更快**：，顺序集成可能会移除很多不必要的指令，这可能会加快速度。

**内联函数可能会使代码速度\*更慢\*：**过多的内联可能会使代码膨胀，在使用分页虚拟内存的系统上，这可能会导致性能下降。换句话说，如果可执行文件过大，系统可能会花费很多时间到磁盘上获取下一块代码。

**内联函数可能会\*增加\*可执行文件尺寸：**这就是上面所说的代码膨胀。例如，假设系统有100个内联函数，每个展开后有100字节，并且被调用了100次。这就会增加1MB的大小。增加这么1MB会导致问题吗？谁知道呢，但很可能就是这1MB导致系统性能下降。

**内联函数可能会\*减少\*可执行文件尺寸：**如果不内联展开函数体，编译器可能会要产生更多代码来压入/弹出寄存器内容和参数。对于很小的函数来说会是这样。如果优化器能够通过顺序集成消除雕大量冗余代码的话，那么对大函数也会起作用（也就是说，优化器能够使大函数变小）。

**内联函数可能会导致系统\*性能下降\*：**内联可能会导致二进制可执行文件尺寸变大，由此导致系统性能下降。

**内联函数可能会\*避免\*系统性能下降：**即使可执行文件尺寸变大，当前正在使用的物理内存数量（即需要同时留在内存中的页面数量）却仍然可能降低。当f()调用g()时，代码经常分散在2个不同的页面上。当编译器将g()的代码顺序集成到f()后，代码通常会放在一个页面上。

**内联函数可能会\*降低\*缓存的命中率：**内联可能会导致内层循环跨越多行的内存缓存，这可能会导致内存和缓存频繁交换，从而性能下降。

**内联函数可能会\*提高\*缓存的命中率：**内联通常能够在二进制代码中就近安排所用到的内容，这可能会减少用来存放内层循环代码的缓存数量。最终这会使CPU密集型程序跑得更快。

**内联函数可能与速度\*无关\*：**大多数系统不是CPU密集型的，而使I/O密集型的、数据库密集型的或是网络密集型的。这表明系统的瓶颈存在于文件系统、数据库或网络。除非你的“CPU速度表”指示是100%，否则内联函数可能不会使你的系统速度更快。（即使是CPU密集型的系统，也只有在被用到瓶颈之处时，内联才会有帮助。而瓶颈通常只存在于很少一部分代码中。）

##### 四，结构体的成员类型不能是自己

结构体的成员不能是自己，否则会导致递归定义，结构体在完成定义之前是incomplete type（不完全类型），不完全类型不能定义对象，只能定义引用和指针，或者用于声明函数的形参和返回值类型。

```
struct A{A a};   //错误，结构体成员不能是自己
```

```
struct A{A* a};   //结构体成员可以是自身的指针类型
```

```
struct A{A& a};   //结构体的成员可以是自身的引用类型
```

##### 五，结构体指针

对于以下结构体：

```
struct
{
	int len;
	char* str;
}*p;
```

有以下几种访问方式：

```
p->str++;   //正确
(*p).str++;  //正确
(*p)->str++;   //错误
```

结构体指针访问成员用“->"

结构体变量访问指针用”."

p为结构体指针，*p相当于结构体变量