#### 分割等和子集 416

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。



##### 方法一：DFS

```
bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (auto x: nums) {
            sum += x;
        }
        if (sum % 2 != 0) return false;
        sum = sum / 2;
        sort(nums.begin(), nums.end());
        return dfs(nums, sum, 0);
    }

    bool dfs(vector<int>& nums, int sum, int index) {
        if (index >= nums.size() || sum < 0) return false;
        if (sum == 0) return true;
        if (dfs(nums, sum - nums[index],  index+1) || dfs(nums, sum, index + 1))
        return true;
        return false;
    }
```

##### 方法二：二维动态规划

```
bool canPartition(vector<int>& nums) {
        int sum = 0, m = nums.size(), mval = 0;
        for (auto x: nums) {
            sum += x;
            mval = max(mval, x);
        }
        if (m==1|| sum % 2 != 0 || mval > sum/2) return false;
        sum = sum / 2;
        vector<vector<bool>> dp(m, vector<bool>(sum+1, false));
        for (int i = 0;i<m;i++) {
            dp[i][0] = true;
        }
        dp[0][nums[0]] = true;
        for (int i = 1;i<m;i++) {
            for (int j = 1;j<=sum;j++) {
                if (j < nums[i]) dp[i][j] = dp[i-1][j];
                else {
                    dp[i][j] = dp[i-1][j-nums[i]] || dp[i-1][j];
                }
            }
        }
        return dp[m-1][sum];
    }
```

##### 方法三：一维动态规划

```
 bool canPartition(vector<int>& nums) {
        int sum = 0, m = nums.size(), mval = 0;
        for (auto x: nums) {
            sum += x;
            mval = max(mval, x);
        }
        if (m==1|| sum % 2 != 0 || mval > sum/2) return false;
        sum = sum / 2;
        vector<bool> dp(vector<bool>(sum+1, false));
        dp[0] = true;
        for (int i = 0;i<m;i++) {
            for (int j = sum;j > 0;j--) {
               if (j >= nums[i]) dp[j] = dp[j] | dp[j-nums[i]];
            }
        }
        return dp[sum];
    }
```

