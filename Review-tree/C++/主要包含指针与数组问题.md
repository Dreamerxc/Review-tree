##### 一，n&(n-1)作用

作用：求其二进制中1的个数。

##### 二，声明一个指向含有10个元素的数组的指针，其中每个元素是一个函数指针，该函数的返回值是int，参数是int*。

1，先考虑数组指针：int(*p)[10]。

2，然后考虑函数指针：int (\*pf)(int\*)。

3，把数组指针当作一个整体代替pf,得int(\*(\*p)[10]))(int\*);

##### 三，默认形参问题

1，默认实参作为形参的初始值出现在形参列表中。我们可以为一个或多个形参定义默认值，不过需要注意一点的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值；

```
int add(int x = 5,int y,int z); 
```

上述程序是错误的，x有初始形参，所以y,z也一定要有初始值。

```
int add(int x,int y = 5,int z = 1);
```

一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

##### 四，typedef问题

```
typedef  char T[10] ; 
T * a ;
T b;
```

此时a等价于 char (a*)[10]  为一个数组指针。

b等价于char b[10]。

##### 五，观察以下程序输出

```
char *a[] = {"BEIJING", "SHENZHEN", "SHANGHAI", "GUANGZHOU"};
char **pa[] = {a+3, a+2, a+1, a};
char ***ppa = pa;
int main(void) {
    printf("%s, ", **++ppa);
    printf("%s, ", *--*++ppa+3);
    printf("%s, ", *ppa[-2]+3);
    printf("%s", ppa[-1][-1]+1);
}

```

![img](https://uploadfiles.nowcoder.com/images/20200105/831729261_1578207736656_13CA8422D2DE4A56BC0A6648BC5B674F)

```
/* ``对于指针ppa
    ``指针类型：``char` `***
    ``指针指向：pa[``0``]
    ``指针指向类型：``char` `**
 ``//指针的指向决定其偏移起始位置，指针指向的类型决定其每次移动偏移量大小
*/
printf(``"%s, "``, **++ppa);
/*
  ``运算符优先级：++ 与 * 运算符同优先级，结合性都是自右向左
  ``++ppa
    ``ppa自增，指向改变，向后移动一位,偏移量为``char` `**,指向pa[``1``]
  ``*++ppa
    ``取出内容,pa[``1``],pa[``1``]又指向a[``2``]
  ``**++ppa
    ``取出内容,a[``2``],a[``2``]又指向字符串``"SHANGHAI"``,printf输出 SHANGHAI
*/
printf(``"%s, "``, *--*++ppa+``3``);
/*
  ``运算符优先级：++/-- 优先级大于 + ,且 + 的结合性是从左往右
  ``++ppa
    ``上一次操作已改变ppa的指向为pa[``1``],再次移动，指向pa[``2``]
  ``*++ppa
    ``取出内容,pa[``2``],pa[``2``]又指向a[``1``]
  ``--*++ppa
    ``//此时，【*++ppa】是一个char **指针，指向a[1],
//则其偏移的起始位置为a[1],偏移量为char *
    ``--使其自减，指针向前移动，从a[``1``]向前移动一个``char``*的大小，指向a[``0``]
  ``*--*++ppa
    ``取出内容，a[``0``]，a[``0``]又指向字符串``"BEIJING"
  ``*--*++ppa+``3
    ``//此时【*--*++ppa】是一个char *指针，指向一个字符串，则其偏移的起始位置
//为字符串的首字符，偏移量为char
    ``+``3``使指针向后移动``3``次，每次移动一个``char``，移动完成后指向字符``'J'` `,printf
输出，从字符``'J'``的位置往后输出打印到STDOUT,输出 JING
*/
 ``printf(``"%s, "``, *ppa[-``2``]+``3``);
/*
  ``[]作用符：【例子】
  ``int` `arr[]{ ``0``,``1``,``2``,``3` `};
  ``int` `*p=arr;
  ``++p;
  ``cout << p[``1``] << ``" "` `<< *(p + ``1``) << endl;
  ``cout << p[-``1``] << ``" "` `<< *(p - ``1``) << endl;
  ``//p[1]等价于*(p + 1)  p[-1]等价于*(p - 1)
  ``ppa[-``2``]
    ``等价于*(ppa-``2``)
      ``ppa-``2
        ``//经过前两次操作，ppa指向pa[2],移动后指向pa[0],【但ppa
//本身的指向并没有改变，还是指向pa[2]】
      ``*(ppa-``2``)
        ``取出内容，pa[``0``],pa[``0``]又指向a[``3``]
  ``*ppa[-``2``]
    ``取出内容，a[``3``]，a[``3``]又指向字符串``"GUANGZHOU"
  ``*ppa[-``2``]+``3
    ``+``3``使指针移动到字符``'N'``,printf输出 NGZHOU
*/
printf(``"%s"``, ppa[-``1``][-``1``]+``1``);
/*
  ``//类似与ppa[-2]等价于*(ppa-2),ppa[-1][-1]等价于*(*(ppa-1)-1)
  ``ppa[-``1``]
    ``等价于*(ppa-``1``)
      ``//经过前三步操作，ppa指向pa[2]，移动后，指向pa[1],
//取出内容pa[1],pa[1]又指向a[2]
  ``ppa[-``1``][-``1``]
    ``等价于*(*(ppa-``1``)-``1``)
      ``*(ppa-``1``)-``1
        ``将上一步操作中的*(ppa-``1``)看做一个整体，是一个``char` `**指针，
指向类型为``char` `* 的a[``2``]
        ``则指针 *(ppa-``1``) 偏移的起始位置为a[``2``]，向前移动一次，
偏移量为``char` `*,移动后指向a[``1``]
      ``*(*(ppa-``1``)-``1``)
        ``取出内容，a[``1``]，a[``1``]又指向字符串``"SHENZHEN"
  ``ppa[-``1``][-``1``]+``1
    ``+``1``指针其移动到字符``'H'``,printf输出 HENZHEN
*/
```

##### 六，下列哪个语句指向二维数组的第一个元素

```
int A[10][10];
int *p;
p = A;  //此时无法通过编译，A是一个二级指针，p是一个指针，二者类型不同，无法通过编译。
p = A[0];  //A[0]相当于一维数组，相当于对第一个元素取地址。
p = &A[0][0]  //取第一个元素地址给p。
```

