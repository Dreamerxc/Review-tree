一，观察一下程序：

```
int *p,m = 0;
*p = m;
```

上面这段程序是错误的，因为p是指针变量，并没有指向某一内存单元，p是野指针，给野指针赋值是错的。

二，7&3+12 = 15？

上面的结果是错误的，此题考虑的是符号的优先级问题。+的优先级高于&。

|     优先级      |            运算符             |                      说明                      |  结合性  |
| :-------------: | :---------------------------: | :--------------------------------------------: | :------: |
|        1        |              ::               |                    范围解析                    | 自左向右 |
|        2        |             ++ --             |               后缀自增/后缀自减                |          |
|       ()        |             括号              |                                                |          |
|       []        |           数组下标            |                                                |          |
|        .        |       成员选择（对象）        |                                                |          |
|       −>        |       成员选择（指针）        |                                                |          |
|        3        |             ++ --             |               前缀自增/前缀自减                | 自右向左 |
|       + −       |             加/减             |                                                |          |
|       ! ~       |        逻辑非/按位取反        |                                                |          |
|     (type)      |         强制类型转换          |                                                |          |
|        *        |        取指针指向的值         |                                                |          |
|        &        |          某某的地址           |                                                |          |
|     sizeof      |          某某的大小           |                                                |          |
|    new,new[]    | 动态内存分配/动态数组内存分配 |                                                |          |
| delete,delete[] | 动态内存释放/动态数组内存释放 |                                                |          |
|        4        |            .* ->*             |           成员对象选择/成员指针选择            | 自左向右 |
|        5        |            * /  %             |                 乘法/除法/取余                 |          |
|        6        |              + −              |                   加号/减号                    |          |
|        7        |             << >>             |                 位左移/位右移                  |          |
|        8        |             < <=              |                 小于/小于等于                  |          |
|      > >=       |         大于/大于等于         |                                                |          |
|        9        |             == !=             |                  等于/不等于                   |          |
|       10        |               &               |                     按位与                     |          |
|       11        |               ^               |                    按位异或                    |          |
|       12        |              \|               |                     按位或                     |          |
|       13        |              &&               |                     与运算                     |          |
|       14        |             \|\|              |                     或运算                     |          |
|       15        |              ?:               |                   三目运算符                   | 自右向左 |
|       16        |               =               |                      赋值                      |          |
|                 |             += −=             |             相加后赋值/相减后赋值              |          |
|                 |           *= /=  %=           |        相乘后赋值/相除后赋值/取余后赋值        |          |
|                 |            <<= >>=            |             位左移赋值/位右移赋值              |          |
|                 |           &= ^=\|=            | 位与运算后赋值/位异或运算后赋值/位或运算后赋值 |          |
|       17        |             throw             |                    抛出异常                    |          |
|       18        |               ,               |                      逗号                      | 自左向右 |

三，观察一下程序：

```
class A
{
    public:
        A()
        {
            printf(“0”);
        }
        A(int a)
        {
            printf(“1”);
        }
        A& operator=(const A& a)
        {
            printf(“2”);
            return*this;
        }
};
int main()
{
    A al;     //调用默认构造函数
    al=10;    //类型不匹配，调用构造函数A(int)进行隐式转化
    		  //调用赋值构造函数
    return 0;
}
```

运行结果如下：

![image-20200626225033011](C:\Users\谯保林\AppData\Roaming\Typora\typora-user-images\image-20200626225033011.png)

四，观察以下程序：

```
**** 在80x86架构下运行 ****
#include <stdio.h>
union Test
{
	char a[4];
	short b;
};
int main()
{
	Test test;
	test.a[0] = 256;
	test.a[1] = 255;
	test.a[2] = 254;
	test.a[3] = 253;
	printf("%d\n", test.b);
}
```

运行解果：

![image-20200626230650575](C:\Users\谯保林\AppData\Roaming\Typora\typora-user-images\image-20200626230650575.png)

解释：

1，Test为联合体，所以char数组和short类型公用一段内存，char数组四个字节，short两个字节。

2，80x86架构下，数据储存采用小端模式。

3，short占两个字节，所以成员b的数据在a[0],a[1]处，有因为采用小端模式，所以a[0]低地址存放低字节，a[1]高地址存放高字节。

又因为char的取值范围为-128~127，发生了溢出，切换到取值范围就是0，所以b的二进制表示为：1111111100000000，计算机采用补码存储，转换为10进制为-256.