#### 一，void型指针

（1）void*是一种特殊的指针，它没有类型（不能判断出指向对象的长度）

（2）任何指针都可以赋值给void指针

```
int a = 10;
void* p;
p = &a;
cout<<*(int*)p;   //解指针时，需要指明类型，否则会发生错误。
```

（3）void指针赋值给其他类型的指针时都要进行转换

```
float *p1;
void *p2;
p1 = (float*)p2;
```

（4）如果函数的参数类型是任意类型指针，那就应声明其参数为void*类型。

```
典型的如内存操作函数memcpy和memset的函数原型分别为：

　　void * memcpy(void *dest, const void *src, size_t len);

　　void * memset ( void * buffer, int c, size_t num );
```

#### 二，continue只能用于循环结构

continue语句只能用于bai循环语句，碰到continue语句就表示不执行后面的语句，直接转到下一次循环的开始

#### 三，逗号表达式

逗号表达的求值顺序是从左向右以此计算用逗号分隔的各表达式的值，

最后一个表达式的值就是整个逗号表达式的值

```
int a = 10, b = 5;
int c = (a, b);    //c = 5;
```

#### 四，宏定义的优点

（1）**方便程序进行修改**：使用简单宏定义可用宏代替一个在程序中经常使用的常量，这样在将该常量改变时，不用对整个程序进行修改，只修改宏定义的字符串即可，而且当常量比较长时， 我们可以用较短的有意义的标识符来写程序，这样更方便一些。

（2）**提高程序的运行效率**：

使用带参数的宏定义可完成函数调用的功能，又能减少系统开销，提高运行效率。正如C语言中所讲，函数的使用可以使程序更加模块化，便于组织，而且可重复利用，但在发生函数调用时，需要保留调用函数的现场，以便子 函数执行结束后能返回继续执行，同样在子函数执行完后要恢复调用函数的现场，这都需要一定的时间，如果子函数执行的操作比较多，这种转换时间开销可以忽 略，但如果子函数完成的功能比较少，甚至于只完成一点操作，如一个乘法语句的操作，则这部分转换开销就相对较大了，但使用带参数的宏定义就不会出现这个问 题，因为它是在预处理阶段即进行了宏展开，在执行时不需要转换，即在当地执行。

#### 五，链接库

**1 静态链接库的优点** 

 (1) 代码装载速度快，执行速度略比动态链接库快； 

 (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 

**2 动态链接库的优点** 

 (1) 更加节省内存并减少页面交换；

 (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；

 (3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；

 (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。

**3 不足之处**

 (1) 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；

 (2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。