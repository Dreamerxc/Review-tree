一，指针与数组的结合

int *pa[5] : []优先级比\*高，pa[5]表明pa是一个数组，大小是5，int\*表明pa是一个指针。

​					所以int *pa[5]  表示为包含5个int\*元素的数组。

int(\*p)[5] : 首先()优先级比[]高，所以pa先与*结合，*pa表明pa是一个指针。

​					所以int(\*p)[5] 表示为指向一个大小为5的int型数组的指针。

二，分析以下代码

```
class Base {
char data[3];
public:
virtual void f() { cout << "Base::f" << endl; }
virtual void g() { cout << "Base::g" << endl; }
virtual void h() { cout << "Base::h" << endl; }

};
int main()
{
cout << sizeof(Base)<< endl;     //Base占8个字节。
return 0;
}
```

解释：类中虚函数存放的只是虚函数表的指针，4个字节，加上char求组的3个字节，对齐以后就是8字节。

资料扩展：

```
C++的编译器一旦发现一个类型中有虚拟函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在32位的机器上，一个指针占4个字节的空间，因此sizeof(类)是4。
C++标准规定类的大小不为0，空类的大小为1，当类不包含虚函数和非静态数据成员时，其对象大小也为1。 如果在类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针指向虚函数表VTable，在32位机器上，一个对象会增加4个字节来存储此指针，它是实现面向对象中多态的关键。而虚函数本身和其他成员函数一样，是不占用对象的空间的。
```

三，关于C++的静态编译：

分析以下代码：

```
class A{
    public:
    void test(){printf("可以运行。。");}
};
int main(){
    A*pA=NULL;
    pA->test();
return 0;
}
```

分析：这段代码对于C++来说是可以编译运行的，但是如果转化为java代码是不能运行的，因为对于非虚成员函数，C++是静态绑定的，java是动态绑定的。

为了保证程序的运行时效率，Ｃ++的设计者认为凡是编译时能确定的事情，就不要拖到运行时再查找了。所以C++的编译器看到这句话会这么干：  
  １：查找  pA  的类型，发现它有一个非虚的成员函数叫  test  。（编译器干的）  
  ２：找到了，在这里生成一个函数调用，直接调A::  test  (  pA  )。  
  所以到了运行时，由于  test  ()函数里面并没有任何需要解引用  pA  指针的代码，所以真实情况下也不会引发segment fault。这里对成员函数的解析，和查找其对应的代码的工作都是在编译阶段完成而非运行时完成的，这就是所谓的静态绑定，也叫早绑定。