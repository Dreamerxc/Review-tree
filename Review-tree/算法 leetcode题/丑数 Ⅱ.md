#### 丑数 Ⅱ：

给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。

**丑数** 就是只包含质因数 `2`、`3` 和/或 `5` 的正整数。

```
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
```



##### 方法一：堆：

```
int nthUglyNumber(int n) {
        vector<int> temp = {2,3,5};
        unordered_set<long> used;
        priority_queue <long,vector<long>,greater<long>> qu;
        qu.push(1);
        int res = 1;
        for(int i  = 0;i<n;i++){
            auto x = qu.top();
            qu.pop();
            res = (int)x;
            for(int i = 0;i<3;i++){
                long t = x*temp[i];
                if(used.find(t)==used.end()){
                    qu.push(t);
                    used.insert(t);
                }
            }
        }
        return res;
    }
```

##### 方法二：动态规划（三指针法）：

```
int nthUglyNumber(int n) {
        vector<int> dp(n+1);
        dp[1] = 1;
        int p1 = 1,p2 = 1,p3 = 1;
        for(int i = 2;i<=n;i++){
            int nums1 = dp[p1]*2,nums2 = dp[p2]*3,nums3 = dp[p3]*5;
            dp[i] = min(nums1,min(nums2,nums3));
            if(dp[i]==nums1) p1++;
            if(dp[i]==nums2) p2++;
            if(dp[i]==nums3) p3++;
        }
        return dp[n];
    }
```

