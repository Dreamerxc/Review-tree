#### 二叉树的序列化和反序列化

##### 一，DFS

```
public:
    void spilt(queue<string>& qu, string data, char sign) {
        int m = data.size();
        if (m==0) return;
        for (int i = 0;i<m;i++) {
            string temp = "";
            while (i < m && data[i] != sign) {
                temp += data[i];
                i++;
            }
            if (temp.size() != 0) qu.push(temp);
        }
        return;
    }

    TreeNode* buildtree(queue<string>& qu) {
        string val = qu.front();
        qu.pop();
        if (val == "None") return nullptr;
        TreeNode* root = new TreeNode(stoi(val));

        root->left = buildtree(qu);
        root->right = buildtree(qu);

        return root;
    }

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if (root == nullptr) return "None";
        string left = serialize(root->left);
        string right = serialize(root->right);
        return to_string(root->val) + "," + left + "," + right;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        queue<string> qu;
        spilt(qu,data,',');
        return buildtree(qu);
    }
```

##### 二，BFS

```
class Codec {
public:

static void _split(const string &s, char delim, 
                   vector<string> &elems) {
    stringstream ss(s);
    string item;
 
    while (getline(ss, item, delim)) {
        elems.push_back(item);
    }
}
 
vector<string> split(const string &s, char delim) {
    vector<string> elems;
    _split(s, delim, elems);
    return elems;
}

    string serialize(TreeNode* root) {
        queue<TreeNode*> qu;
        if (root == nullptr) return "None";
        qu.push(root);
        string res = "";
        while (!qu.empty())
        {
            TreeNode* tmp = qu.front();
            qu.pop();
            if (tmp == nullptr) res += "None";
            else  {
                res += to_string(tmp->val);
                qu.push(tmp->left);
                qu.push(tmp->right);
            }
            res += ",";
        }
        return res;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if (data == "None") return nullptr;
        vector<string> temp = split(data,',');
        TreeNode* root = new TreeNode(stoi(temp[0]));
        int index = 1;
        queue<TreeNode*> qu;
        qu.push(root);
        while (!qu.empty()) {
            TreeNode* node = qu.front();
            qu.pop();
            if (temp[index] == "None") node->left = nullptr;
            else {
                TreeNode* left = new TreeNode(stoi(temp[index]));
                node->left = left;
                qu.push(left);
            }
            if (temp[index+1] == "None") node->right = nullptr;
            else {
                TreeNode* right = new TreeNode(stoi(temp[index+1]));
                node->right = right;
                qu.push(right);
            }
            index += 2;
        }
        return root;
    }
};
```

