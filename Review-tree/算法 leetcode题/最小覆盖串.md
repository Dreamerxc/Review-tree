#### 最小覆盖串

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。



```
示例：
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```



##### 方法一：滑动窗口版本一（8.75% ， 5.01%）

```
bool isok(map<char, int> mp, string t) {
        for (auto x: t) {
            if (mp[x]<=0) return false;
            mp[x]--;
        }
        return true;
    }

    string minWindow(string s, string t) {
        // 滑动窗口
        map<char, int> mp;
        int left = 0,right = 0;
        int m = s.size(),res = m;
        string ret = "";
        while(right<=m){
            while (isok(mp, t)) {
                if (right - left<=res){
                    ret = s.substr(left, right - left);
                   // cout<<left<<right<<ret<<endl;
                   res = min(right - left,res);  
                }
                mp[s[left]]--;
                left++;
            }
            if(right<m) mp[s[right]]++;
            right++;
        }
        return ret;
    }
```

##### 方法二：滑动窗口版本二（79.0%, 79.6%)

```
string minWindow(string s, string t) {
        vector<int> mp(128);
        for (auto x : t) {
            mp[x]++;
        }
        int start = 0,minLen = INT_MAX,left = 0,right = 0,needs = t.size();
        while (right < s.size()) {
            if (mp[s[right]]>0) needs--;
            mp[s[right]]--;
            right++;
            while(needs == 0){
                if (right - left < minLen){
                    start = left;
                    minLen = right - left;
                }
                mp[s[left]]++;
                if(mp[s[left]]>0) needs++;
                left++;
            }
        }
        if (minLen == INT_MAX) return "";
        return s.substr(start,minLen); 
    }
```

