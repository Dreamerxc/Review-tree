#### 组合排序：

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

- 所有数字（包括 target）都是正整数。
- 解集不能包含重复的组合。 

```
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```

##### 回溯 + 剪枝：

版本一：

```
vector<vector<int>> res;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        // 回溯法
        vector<int> temp;
        sort(candidates.begin(),candidates.end());
        bracktrack(candidates,temp,target,0);
        return res;
    }

    void bracktrack(vector<int>& candidates, vector<int>& temp,int target,int index){
        if(target<0) return;
        if(target==0){
            res.push_back(temp);
            return;
        }
        for(int i  = index;i<candidates.size();i++){
            temp.push_back(candidates[i]);
            bracktrack(candidates,temp,target-candidates[i],i);
            temp.pop_back();
        }
    }
```

版本二：

```
vector<vector<int>> res;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        // 回溯法
        vector<int> temp;
        sort(candidates.begin(),candidates.end());
        bracktrack(candidates,temp,target,0);
        return res;
    }

    void bracktrack(vector<int>& candidates, vector<int>& temp,int target,int index){
        if(index==candidates.size()) return;
        if(target==0){
            res.push_back(temp);
            return;
        }
        // 直接跳过
       bracktrack(candidates,temp,target,index+1);
       if(target-candidates[index]>=0){
           temp.push_back(candidates[index]);
           bracktrack(candidates,temp,target-candidates[index],index);
           temp.pop_back();
       }
    }
```

