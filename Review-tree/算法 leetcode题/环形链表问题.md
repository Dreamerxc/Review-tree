#### 环形链表问题：

##### 主要运用Floyd算法（龟兔赛跑算法）：

设m为链表起点与环起点的距离，k为第一次相遇点离环起点的位置，n为环的长度，a为龟在第一次相遇时绕环的圈数，b为兔第一次绕环的圈数。

龟跑过的距离：len1 = m + a*n + k

兔跑过的距离:   len2 = m + b*n + k

因为兔的速度是龟的两倍：len1 = len2 - len1 = (b-a)*n，既圈长度的倍数

如何计算环形起点：让龟重新从链表起点出发，如何龟兔一起以相同的速度前进m时，龟兔一定相遇，因为此时龟距离起点m,兔距离起点len1 + m,len1为环的长度，所以一定相遇在环的起点处。

##### 一，判断是否是环形链表

```
 bool hasCycle(ListNode *head) {
        if (head==nullptr||head->next==nullptr) return false;
        ListNode* fast = head;
        while(fast!=nullptr&&fast->next!=nullptr){
            fast = fast->next->next;
            head = head->next;
            if (fast==head) return true;
        }
        return false;
    }
```

##### 二，求出环形链表起点

```
ListNode *detectCycle(ListNode *head) {
       ListNode* fast = head;
       ListNode* low = head;
       while(fast!=nullptr && fast->next!=nullptr){
           fast = fast->next->next;
           low = low->next;
           if(low==fast) break;
       } 
       if(fast==nullptr||fast->next==nullptr) return nullptr;
       low = head;
       while(low!=fast){
           low = low->next;
           fast = fast->next;
       }
       return low;
    }
```

