#### 回文链表

##### 一，存入数组，双指针判断回文

```
bool isPalindrome(ListNode* head) {
        vector<int> temp;
        while (head != nullptr) {
            temp.push_back(head->val);
            head = head->next;
        }
        int left = 0,right = temp.size()-1;
        while (left<right) {
            if (temp[left] != temp[right]) return false;
            left++;
            right--;
        }
        return true;
    }
```

##### 二，快慢指针 + 反转链表

```
bool isPalindrome(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return true;
        ListNode* endFirst = halflist(head);
       // cout<<endFirst->val;
      
        ListNode* secondlist = reverselist(endFirst->next);
         
        ListNode* p1 = head;
        ListNode* p2 = secondlist;

        bool result = true;
        while (p2 != nullptr) {
            if (p2->val != p1->val) {
                result = false;
                break;
            }
            p2 = p2->next;
            p1 = p1->next;
        }
        secondlist = reverselist(secondlist);
        
        endFirst->next = secondlist;
        return result;
    }

    ListNode* halflist(ListNode* head)
    {
        ListNode* fast = head;
        ListNode* low = head;
        while(fast->next != nullptr && fast->next->next != nullptr) {
            fast = fast->next->next;
            low = low->next;
        }
        return low;
    }

    ListNode* reverselist(ListNode* head) {
        ListNode* pre = nullptr;
        while(head != nullptr) {
            ListNode* temp = head->next;
            head->next = pre;
            pre = head;
            head = temp;
        }
        return pre;
    }
```

