#### 回文字串

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

```
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```



##### 方法一：动态规划

```
 int countSubstrings(string s) {
        int m = s.size(), res = 0;
        vector<vector<bool> >dp(m, vector<bool>(m,false));
        for (int i = 0;i < m;i++) {
            dp[i][i] = true;
            res++;
            for (int j = 0;j<i;j++) {
                if (s[i] == s[j]) {
                    if (i == j+1) dp[j][i] = true;
                    else dp[j][i] = dp[j+1][i-1];
                }
                else dp[j][i] = false;
                if (dp[j][i]) res++;
            }
        }
        return res;
    }
```

##### 方法二：中心扩展算法，找到扩展的中心点

```
int countSubstrings(string s) {
        int m = s.size(), res = 0;
        for (int i = 0;i <2 * m - 1;i++) {
            int left = i/2;
            int right = left + i%2;
            while (left >=0 && right < m && s[left] == s[right]) {
                res++;
                left--;
                right++;
            }
        }
        return res;
    }
```





#### 最长回文字串

##### 方法一：动态规划

```
string longestPalindrome(string s) {
        int n = s.size();
        string res = "";
        vector<vector<bool>> dp(n,vector<bool>(n,false));
        for(int i = 0;i<n;i++){
            dp[i][i] = true;
        }
        for(int i = n-1;i>=0;i--){
            for(int j = i;j<n;j++){
                if(s[i]!=s[j]){
                    dp[i][j] = false;
                }else{
                    if(j-i<3) dp[i][j] = true;
                    else dp[i][j] = dp[i+1][j-1];
                    if(dp[i][j]&&j-i+1>res.size()){
                        res = s.substr(i,j-i+1);
                    }
                }
            }
        }
        return res;
    }
```

##### 方法二：中心扩展算法

```
string longestPalindrome(string s) {
        int m = s.size();
        string res;
        for (int i = 0;i <2 * m - 1;i++) {
            int left = i/2;
            int right = left + i%2;
            while (left >=0 && right < m && s[left] == s[right]) {
                if (right - left + 1> res.size()) {
                    res = s.substr(left, right - left + 1);
                }
                left--;
                right++;
            }
        }
        return res;
    }
```

